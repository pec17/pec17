              ITICKET
	//Application properties
	server.port=2222
	server.servlet.context-path=/ITicket	
			//TicketDTO
	@NotNull(message = "{ticket.phonenumber.notpresent}")
	@Pattern(regexp = "[1-9]\\d{9}", message = "ticket.phonenumber.invalid}")
	private String phoneNumber;
	
	@NotEmpty(message = "{ticket.emailid.notpresent}")
	@Email(message = "{ticket.emailid.invalid}")
	private String emailId;
	
	@NotNull(message = "{ticket.issue.notpresent}")
	@Pattern(regexp = "[a-zA-Z]+([ ]?[a-ZA-Z]+)*" , message="{ticket.issue.invalid}")
	private String issue;
	
	@NotNull(message="{ticket.raisedby.notpresent}")
	@Min(value=100, message = "{ticket.raisedby.invalid}")
	@Max(value=999, message = "{ticket.raisedby.invalid}")
	private Integer raisedBy;
	
	@NotNull(message="{ticket.category.notpresent}")
	@Pattern(regexp="(ccd|cag|facility)", message = "{ticket.category.invalid}")
	private String category;
	
	@Min(value=1000, message="{ticket.ticketnumber.invalid}")
	@Max(value =9999, message="{ticket.ticketnumber.invalid}")
	public Integer getTicketNumber() {
		return ticketNumber;
	}
	//ExceptionControllerAdvice
	@RestControllerAdvice
	  public class ExceptionControllerAdvice
private final Logger logger = LoggerFactory.getLogger(this.getClass());

	  @ExceptionHandler(Exception.class)
	public ResponseEntity<ErrorInfo> generalExceptionHandler(Exception exception){
		ErrorInfo errorInfo = new ErrorInfo();
		errorInfo.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
		errorInfo.setErrorMsg(environment.getProperty(TicketConstants.GENERAL_EXCEPTION_MESSAGE.toString()));
		return new ResponseEntity<>(errorInfo,HttpStatus.INTERNAL_SERVER_ERROR);
	}
	@ExceptionHandler(TicketException.class)
	public ResponseEntity<ErrorInfo> ticketExceptionHandler(TicketException e){
		ErrorInfo errorInfo = new ErrorInfo();
		errorInfo.setErrorCode(HttpStatus.BAD_REQUEST.value());
		errorInfo.setErrorMsg(e.getMessage());
		return new ResponseEntity<>(errorInfo,HttpStatus.BAD_REQUEST);
	}
	@ExceptionHandler({MethodArgumentNotValidException.class,ConstraintViolationException.class})
    public ResponseEntity<ErrorInfo>exceptionHandler(Exception ex){}
	
	    //TicketServiceImpl
	public long getMaxEmails(String firstChar) throws TicketException{
		List<String> emailIds = ticketRepository.findAllEmailIds();
		return emailIds.stream().filter(email -> email.startsWith(firstChar)).count();
	}
List<Ticket> list = ticketRepository.findAll();
	return list.stream().filter(ticket -> ticket.getEmailId().startsWith(firstChar)).count();
	//TicketController
	@RestController
	@Validated
	public class TicketController{
		@Autowired
		TicketServiceImpl ticketService;
		
		@PostMapping(value="/ticket")
		public ResponseEntity<TicketDTO> raiseTicket(@Valid @RequestBody TicketDTO ticketDTO) throws TicketException{
			TicketDTO ticketDTO2 = ticketService.raiseTicket(ticketDTO);
			return new ResponseEntity<>(ticketDTO2,HttpStatus.CREATED);
		}
	    @GetMapping(value="/ticket/{ticketNumber}")
	    public ResponseEntity<TicketDTO> searchTicket(@PathVariable
	    		                                      @Min(value=1000, message="{ticket.ticketnumber.invalid}")
	                                                  @Max(value =9999, message="{ticket.ticketnumber.invalid}") 
	                                                      Integer ticketNumber) throws TicketException{
	    	TicketDTO ticketDTO2 = ticketService.searchTicket(ticketNumber);
	    	return new ResponseEntity<>(ticketDTO2,HttpStatus.OK);	    
	    	}
	    @GetMapping(value="/emailids/{firstChar}")
	    public ResponseEntity<Long>getMaxRepeatedEmails(@PathVariable String firstChar){
	    	long count = ticketService.getMaxEmails(firstChar);
	    	return new ResponseEntity.OK(count);
	    }
	       @GetMapping(value="/ticket")
	    public ResponseEntity<List<TicketDTO>> getReport(@RequestParam("emailId")
	                                                                     @NotEmpty(message = "{ticket.emailid.notpresent}")
	                                                                       @Email(message = "{ticket.emailid.invalid}")
	                                                                         String emailId) throws TicketException{
	    	List<TicketDTO> ticketDTOs = ticketService.getReport(emailId);
	    	return new  ResponseEntity<List<TicketDTO>>(ticketDTOs, HttpStatus.OK); 
	    }
//======================================================================================================	
	INFYRIDE
  //application properties
	    server.port=/InfyRide
		server.servlet.context-path=/InfyRide	
	    //RideDTO-----
	@NotBlank(message = "{ride.pickuplocation.notpresent}")  || @Pattern(regexp= ".*\\S.*" ,message = "{ride.pickuplocation.notpresent}")
	//private String pickupLocation;
	@NotBlank(message="{ride.droplocation.notpresent}") || @Pattern(regexp= ".*\\S.*" ,message = "{ride.pickuplocation.notpresent}")
	//private String dropLocation;
	@NotNull(message= "{ride.datetime.notpresent}")
	@FutureOrPresent(message="{ride.datetime.invalid}")
	//private LocalDateTime rideDateTime;
	public String getPickupLocation() {
		return pickupLocation;
	}
	public void setPickupLocation(String pickupLocation) {
		this.pickupLocation = pickupLocation;
	}
         //CancelbookingDTO----
	@NotNull(message = "{ride.reasonforcancellation.notpresent}")
	@Pattern(regexp="(?=.*[a-zA-Z0-9].*)[a-zA-Z0-9.,! ]*" ,message="{ride.reasonforcancellation.invalid}" )
	//private String reasonForCancellation;
	 public String getReasonForCancellation() {
		return reasonForCancellation;
	}
	public void setReasonForCancellation(String reasonForCancellation) {
		this.reasonForCancellation = reasonForCancellation;
	}
	//serviceImpl-------
	public String bookRide(RideDTO rideDTO) throws InfyRideException{
		FareEntity fe = fareRepository.getByPickupLocationIgnoreCaseAndDropLocationIgnoreCase(rideDTO.getPickupLocation(),rideDTO.getDropLocation);
		if(fe==null) {
			throw new InfyRideException(InfyRideConstants.INFYRIDE_PICKUPTODROPLOCATION_NOT_FOUND.toString())
		}
		double s= fe.getFare();
		RideEntity re ;
		re = RideDTO.prepareRideEntity(rideDTO);
		re.setStatus("BOOKED");
		re.setTotalFare(fe.getFare());
		rideRepository.save(re);
		return environment.getProperty(InfyRideConstants.INFYRIDE_BOOKING_SUCCESS.toString())+s;
	}
	   //ExceptionControllerAdvice--
	   @RestControllerAdvice
	   //public class ExceptionControllerAdvice
private final Logger logger = LoggerFactory.getLogger(this.getClass());
	   @ExceptionHandler(Exception.class)
	   public ResponseEntity<ErrorInfo> generalExceptionHandler(Exception ex){
		   logger.error(ex.getMessage(),ex);
		   ErrorInfo errorInfo = new ErrorInfo();
		   errorInfo.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
		   errorInfo.setErrorMsg(environment.getProperty(InfyRideConstants.INFYRIDE_EXCEPTIONMSG_GENERAL.toString()));
		   return new ResponseEntity<>(errorInfo,HttpStatus.INTERNAL_SERVER_ERROR);
	   }
	   @ExceptionHandler(InfyRideException.class)
	   public ResponseEntity<ErrorInfo>infyRideExceptionHandler(InfyRideException ex){
		   logger.error(ex.getMessage(),ex);
		   ErrorInfo errorInfo = new ErrorInfo();
		   errorInfo.setErrorCode(HttpStatus.BAD_REQUEST.value());
		   errorInfo.setErrorMsg(environment.getProperty(ex.getMessage()));
		   return new ResponseEntity<>(errorInfo,HttpStatus.BAD_REQUEST);
	   }
	   @ExceptionHandler({MethodArgumentNotValidException.class,ConstraintViolationException.class})
	    public ResponseEntity<ErrorInfo>exceptionHandler(Exception ex){}
	    //Ride controller----
	    @RestController
	    @Validated
	    public class InfyRideController{
	    	
	    	@Autowired
	    	private InfyRideService infyRideService;
	    	@PostMapping(value="/ride")
	    	public String bookRide(@Valid @RequestBody RideDTO rideDTO) throws InfyRideException{
	    		String msg = infyRideService.bookRide(rideDTO);
	    		return msg;
	    	}
	    	@GetMapping(value="ride/{pickupLocation}/{dropLocation}")
	    	public String getEstimatedFare(@PathVariable String pickupLocation,@PathVariable String dropLocation)throws InfyRideException{
	    		String msg = infyRideService.getEstimatedFare(pickupLocation.trim(), dropLocation.trim());
	    		return msg;
	    	}
	    	@PutMapping(value="ride/{rideId}/{newPickupLocation}")
	    	public String updateRide(@PathVariable @Min(value=1,message="{ride.rideid.invalid}") int rideId , @PathVariable String newPickupLocation )throws InfyRideException{
	    		String msg = infyRideService.updateRide(rideId,newPickupLocation);
	    		return msg;
	    	}
	    	@DeleteMapping(value = "ride/{rideId}")
	    	public String cancelRide(@PathVariable @Min(value=1,message="{ride.rideid.invalid}") int rideId , @RequestBody @Valid CancelBookingDTO cancelBookingDTO)throws InfyRideException{
	    		String msg = infyRideService.cancelRide(rideId,cancelBookingDTO);
	    		return msg;
	    	}
	    }
//====================================================================================================
INFYBANK

	//Application properties
	        server.port=2222
			server.servlet.context-path=/InfyBankBranchService
		//BranchDTO
			@NotNull(message="{branch.openingtime.invalid}")
	        private LocalTime openingTime;
	        @NotNull(message="{branch.closingtime.invalid}")
	        private LocalTime closingTime;
	        @NotBlank(message="{branch.type.notpresent}")
	        @Pattern(regexp = "(Retail|Commercial|Overseas)",message = "{branch.type.invalid}")
	        private String branchType;
	        @NotBlank(message = "{branch.address.invalid}")
	        private String address;
	        @Min(value = 100000,message = "{branch.pincode.invalid}")
	        @Max(value = 999999,message = "{branch.pincode.invalid}")
	        private long pinCode;
	        @Min(value = 1000000000l,message = "{branch.phonenumber.invalid}")
	        @Max(value = 9999999999l,message = "{branch.phonenumber.invalid}")
	        private long phoneNumber;
	      //BranchUpdateDTO
	        @Min(value = 1000,message = "{branch.code.invalid}")
	        private int branchcode;
	        @Pattern(regexp = "(Retail|Commercial|Overseas)",message = "{branch.type.invalid}")
	        private String branchType;
	      //serviceIMPL
	        public BranchDTO addBranch(BranchDTO branchDTO) throws InfyBankBranchException{
	        	BranchDetailsValidator.validateTimings(branchDTO.getOpeningTime(),branchDTO.getClosingTime());
	        	List<BranchEntity> branches = branchRepository.findByAddress(branchDTO.getAddress());
	        	if(!branches.isEmpty()) {
	        		throw new InfyBankBranchException("BranchServiceImpl.DUPLICATE_BRANCH");
	        	}
	        	List<BranchEntity>branchByPhones = branchRepository.findByPhoneNumber(branchDTO.getPhoneNumber());
	        	if(!branchByPhones.isEmpty()) {
	        		throw new InfyBankBranchException("BranchServiceImpl.PHONENUMBER_ALREADY_EXISTS");
	        	}
	        	BranchEntity be = BranchDTO.dtoToEntityConverter(branchDTO);
	        	be.setBranchCode(branchRepository.getMaxBranchCode()+1);
	        	be.setIfscCode("INFY000"+ be.getBranchCode());
	        	be.setEmailId("infybank."+be.getBranchCode()+"@infybank.co.in");
	        	be.setStatus("ACTIVE");
	        	
	        	branchRepository.save(be);
	        	branchDTO.setBranchCode(be.getBranchCode());
	        	branchDTO.setIfscCode(be.getIfscCode());
	        	branchDTO.setEmailId(be.getEmailId());
	        	branchDTO.setStatus(be.getStatus());
	        	return branchDTO;
	        }
	      //ExceptionHandler
	        @RestControllerAdvice
	        public class GlobalExceptionHandler
private final Logger logger = LoggerFactory.getLogger(this.getClass());
	        @ExceptionHandler(Exception.class)
	    	public ResponseEntity<ErrorInfo> generalExceptionHandler(Exception exception){
	        	logger.error(ex.getMessage(),ex);
	    		ErrorInfo errorInfo = new ErrorInfo();
	    		errorInfo.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
	    		errorInfo.setErrorMsg(environment.getProperty("GENERAL_EXCEPTION_MSG"));
	    		return new ResponseEntity<>(errorInfo,HttpStatus.INTERNAL_SERVER_ERROR);
	    	}
	        @ExceptionHandler(InfyBankBranchException.class)
	    	public ResponseEntity<ErrorInfo> ticketExceptionHandler(InfyBankBranchException ex){
	        	logger.error(ex.getMessage(),ex);
	    		ErrorInfo errorInfo = new ErrorInfo();
	    		errorInfo.setErrorCode(HttpStatus.BAD_REQUEST.value());
	    		errorInfo.setErrorMsg(environment.getProperty(ex.getMessage()));
	    		return new ResponseEntity<>(errorInfo,HttpStatus.BAD_REQUEST);
	    	}
	        @ExceptionHandler({MethodArgumentNotValidException.class,ConstraintViolationException.class})
	        public ResponseEntity<ErrorInfo>exceptionHandler(Exception ex){}
	        
	      //BranchApi
	        @RestController
	    	@Validated
	    	public class BranchAPI{
	        	@Autowired
	        	private BranchService branchService;
	        	
	        	@PostMapping(value = "branch")
	        	public BranchDTO addBranch(@Valid @RequestBody BranchDTO branchDTO) throws InfyBankBranchException{
	        		BranchDTO branchDTO2 = branchService.addBranch(branchDTO);
	        		return branchDTO2;
	        	}
	        	@GetMapping(value = "branch/{pinCode}")
	        	public List<BranchDTO> locateBranches(@PathVariable
	        			@Min(value = 100000,message = "{branch.pincode.invalid}")
		                @Max(value = 999999,message = "{branch.pincode.invalid}")
	        	         long pinCode) throws InfyBankBranchException{
	        		List<BranchDTO> branches = branchService.locateBranches(pinCode);
	        		return branches;
	        	}
	        	@PutMapping(value = "branch")
	        	public BranchDTO updateBranch(@Valid @RequestBody BranchUpdateDTO branchUpdateDTO) throws InfyBankBranchException{
	        		BranchDTO branchDTO = branchService.updateBranch(branchUpdateDTO);
	        		return branchDTO;
	        	}
	        	@DeleteMapping(value = "branch/{branchCode}")
	        	public String deleteBranch(@PathVariable 
	        			@Min(value = 1000,message = "{branch.code.invalid}")
	        	            int branchCode) throws InfyBankBranchException{
	        		String msg = branchService.deleteBranch(branchCode);
	        		return msg;
	        	}
	        }      
	        
//=======================================================================================================
TRIVAINFY
//Application.properties
	       server.port=8080
			server.servlet.context-path=/Trivalnfy
		//BookingDTO
			@NotBlank(message="{booking.hotelname.invalid}")
	       private String hotelName;
	       @NotBlank(message="{booking.vendorname.invalid}")
	       private String vendorName;
	       @Min(value=1,message="{booking.noofrooms.invalid}")
	       private int noOfRooms;
	       //TrivaninfyServiceImpl
	       public List<HotelDTO> searchHotels(String hotelNameSearchKey) throws TrivaInfyException{
	    	   List<Hotel>listHotels = hotelRepository.findByHotelNameContainingIgnoreCase(hotelNameSearchKey);
	    	   if(listHotels.isEmpty()) {
	    		   throw new TrivaInfyException(TrivaInfyConstants.TRIVAINFY_SEARCH_HOTEL_INVALID.toString());
	    	   }
	    	   List<HotelDTO>hoteldtoList = new ArrayList<>();
	    	   for(Hotel hotel : listHotels) {
	    		   if(hotel.getHotelStatus().equals("A")) {
	    			   hoteldtoList.add(HotelDTO.entityToDTOConvertor(hotel));
	    		   }
	    	   }
	    	   if(hoteldtoList.isEmpty()) {
	    		   throw new TrivaInfyException(TrivaInfyConstants.TRIVAINFY_SEARCH_HOTEL_INVALID.toString());
	    	   }else {
	    		   return hoteldtoList;
	    	   }
	       }
	       //ExceptionControllerAdvice
	       @RestControllerAdvice
	 	  public class ExceptionControllerAdvice
private final Logger logger = LoggerFactory.getLogger(this.getClass());
	 	 @ExceptionHandler(Exception.class)
	    	public ResponseEntity<ErrorInfo>generalExceptionHandler(Exception ex){
	    		logger.error(ex.getMessage(),ex);
	    		ErrorInfo errorInfo=new ErrorInfo();
	    		errorInfo.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
	    		errorInfo.setErrorMsg(environment.getProperty(TrivaInfyConstants.TRIVAINFY_EXCEPTIONMSG_GENERAL.toString));
	    		return new ResponseEntity<>(errorInfo,HttpStatus.INTERNAL_SERVER_ERROR);
	    	}
	 	 @ExceptionHandler(TrivaInfyException.class)
	    	public ResponseEntity<ErrorInfo>trivaInfyExceptionHandler(TrivaInfyException ex){
	    		logger.error(ex.getMessage(),ex);
	    		ErrorInfo errorInfo=new ErrorInfo();
	    		errorInfo.setErrorCode(HttpStatus.BAD_REQUEST.value());
	    		errorInfo.setErrorMsg(environment.getProperty(ex.getMessage()));
	    		return new ResponseEntity<>(errorInfo,HttpStatus.BAD_REQUEST);
	    	}
	 	@ExceptionHandler({MethodArgumentNotValidException.class,ConstraintViolationException.class})
        public ResponseEntity<ErrorInfo>exceptionHandler(Exception ex){}
                   //TrivainfyController
	 	@RestController
		@Validated
	 	public class TrivaInfyController{
	 		@Autowired
	 		private TrivaInfyService trivaInfyService;
	 		@GetMapping(value="/hotels/{hotelNameSearchKey}")
	 		public List<HotelDTO> searchHotels(@PathVariable String hotelNameSearchKey) throws TrivaInfyException{
	 			List<HotelDTO> hotelDTOs=trivaInfyService.searchHotels(hotelNameSearchKey.trim());
	 			return hotelDTOs;
	 		}
	 		@GetMapping(value="/vendors/{vendorNameSearchKey}")
	 		public List<vendorDTO> searchVendors(@PathVariable String vendorNameSearchKey) throws TrivaInfyException{
	 			List<vendorDTO> vendorDTOs=trivaInfyService.searchVendors(vendorNameSearchKey.trim());
	 			return vendorDTOs;
	 		}
	 		@PostMapping(value="/booking")
	 		public String bookHotel(@Valid @RequestBody BookingDTO bookingDto) throws TrivaInfyException{
	 			String message = trivaInfyService.bookHotel(bookingDto);
	 			return message;
	 	}
	 		@PutMapping(value="/booking/{bookingId}/{noOfRoomsNew}")
	 		public String updateBooking(@PathVariable
	 				@Min(value=1,message="{booking.bookingid.invalid}") Integer bookingId, @PathVariable
	 				@Min(value=1,message="{booking.noofrooms.invalid}")Integer noOfRoomsNew) throws TrivaInfyException{
	 			String message = trivaInfyService.updateBooking(bookingId, noOfRoomsNew);
	 			return message;
	 		}
	 		@DeleteMapping(value="/booking/{bookingId}")
	 		public String cancelBooking(@PathVariable
	 				@Min(value=1,message="{booking.bookingid.invalid}") Integer bookingId) throws TrivaInfyException{
	 			String message=trivaInfyService.cancelBooking(bookingId);
	 			return message;
	 		}
	 	}

	       
//=====================================================================================================
INFYPANDA
  //Applictaion properties
	server.port=2222
	server.servlet.context-path=/InfyPanda
	
			//InfyPandaServiceImpl
	public List<RestaurantDTO> searchRestaurantsWithItemName(String itemName) throws InfyPandaException{
		Item item = itemRepository.findByItemNameIgnoreCase(itemName);
		if(item==null)
			throw new InfyPandaException(InfyPandaConstrants.INFYPANDA_ITEM_NAME_INVALID.toString());
		List<RestaurantDTO> restraurantList = new ArrayList<>();
		List<Restaurant> restraurants = item.getRestaurants();
		for(Restaurant restraurant: restraurants) {
			restraurantList.add(RestaurantDTO.valueOf(restraurant));
		}
		return restraurantList;
	}
	          //OrderDTO
	@NotBlank(message = "{order.itemname.invalid}")
	private String itemName;
	@NotBlank(message= "{order.restaurantname.invalid}")
	private String restaurantName;
	@Min(value=1,message="{order.quantity.invalid}")
	private int quantity;
	
	public String getItemName() {
		return itemName;
	}
	public void setItemName(String ItemName) {
		this.itemName = ItemName;
	}
	//ExceptionControllerAdvice
	@RestControllerAdvice
	  public class ExceptionControllerAdvice
private final Logger logger = LoggerFactory.getLogger(this.getClass());
	  @Autowired
	  private Environment environment;
	@ExceptionHandler(Exception.class)
	public ResponseEntity<ErrorInfo>generalExceptionHandler(Exception ex){
		logger.error(ex.getMessage(),ex);
		ErrorInfo errorInfo=new ErrorInfo();
		errorInfo.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
		errorInfo.setErrorMsg(environment.getProperty(InfyPandaConstants.INFYPANDA_EXCEPTIONMSG_GENERAL.toString))
		return new ResponseEntity<>(errorInfo,HttpStatus.INTERNAL_SERVER_ERROR);
	}
	@ExceptionHandler(InfyPandaException.class)
	public ResponseEntity<ErrorInfo>InfyPandaExceptionHandler(InfyPandaException ex){
		logger.error(ex.getMessage(),ex);
		ErrorInfo errorInfo=new ErrorInfo();
		errorInfo.setErrorCode(HttpStatus.BAD_REQUEST.value());
		errorInfo.setErrorMsg(environment.getProperty(ex.getMessage()));
		return new ResponseEntity<>(errorInfo,HttpStatus.BAD_REQUEST);
	}
	@ExceptionHandler({MethodArgumentNotValidException.class,ConstraintViolationException.class})
    public ResponseEntity<ErrorInfo>exceptionHandler(Exception ex){}
	
	//InfyPandaController
	@RestController
	@Validated
	public class InfyPandaController{
		@Autowired
		private InfyPandaService infyPandaService;
		
		@GetMapping(value="restaurant/{itemName}")
		public List<RestaurantDTO> searchRestaurantsWithItemName(@PathVariable String itemName)throws InfyPandaException{
			List<RestaurantDTO> restaurants = infyPandaService.searchRestaurantsWithItemName(itemName.trim());
			return restaurants;
		}
		@GetMapping(value="items/{restaurantName}")
		public List<ItemDTO> searchItemsByRestaurantName(@PathVariable String restaurantName)throws InfyPandaException{
			List<ItemDTO> item = infyPandaService.searchItemsByRestaurantName(restaurantName.trim());
			return item;
		}
		@PostMapping(value="/order")
		public String placeOrder(@Valid @RequestBody OrderDTO orderDTO)throws InfyPandaException{
			String successMessage=infyPandaService.placeOrder(orderDTO);
			return successMessage;
		}
		@PutMapping(value= "order/{orderId}/{quantityNew}")
		public String updateOrder(@PathVariable @Min(value=1,message = "{order.orderid.invalid}")Integer orderId, 
				                  @PathVariable @Min(value=1,message = "{order.quantity.invalid}")Integer quantityNew)throws InfyPandaException{
			String successMessage=infyPandaService.updateOrder(orderId,quantityNew);
			return successMessage;
		}
		@DeleteMapping(value = "order/{orderId}")
		public String cancelOrder(@PathVariable @Min(value=1,message="{order.orderid.invalid}")Interger orderId)throws InfyPandaException{
			String successMessage=infyPandaService.cancelOrder(orderId);
			return successMessage;
		}
	
	
		
//=======================================================================================================================
INFYLAPTOP
//Application properties
	        server.port=2222
			server.servlet.context-path=/InfyLaptopService
	//Employee DTO
			@JsonInclude(Include.NON_EMPTY)
			public class EmployeeDTO
			@NotBlank(message="{employee.name.notpresent}")
	        @Pattern(regexp = "(?=.*[a-zA-Z.*)[a-zA-Z]*",message = "{employee.name.invalid}")
	        private String empName;
	        @NotBlank(message="{employee.email.notpresent}")
	        @Email(message = "{employee.email.invalid}")
	        private String emailId;
	        @Min(value=7000000000l,message= "{employee.contactno.invalid}")
	        @Max(value=9999999999l,message= "{employee.contactno.invalid}")
	        private long contactNo;
	        @NotNull(message="{employee.joiningdate.notpresent}")
	        @PastOrPresent(message="{employee.joiningdate.invalid}")
	        private LocalDate joiningDate;
	        @NotNull(message="{employee.mappedtoproject.notpresent}")
	        @Pattern(regexp="[YN]{1}",message = "{employee.mappedtoproject.invalid}")
	        private String mappedToProject;
	        //ExceptionControllerAdvice
	        @RestControllerAdvice
	  	  public class ExceptionControllerAdvice
private final Logger logger = LoggerFactory.getLogger(this.getClass());
	  	@ExceptionHandler(Exception.class)
	    	public ResponseEntity<ErrorInfo>generalExceptionHandler(Exception ex){
	    		logger.error(ex.getMessage(),ex);
	    		ErrorInfo errorInfo=new ErrorInfo();
	    		errorInfo.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
	    		errorInfo.setErrorMsg(environment.getProperty("GENERAL_EXCEPTION_MSG"));
	    		return new ResponseEntity<>(errorInfo,HttpStatus.INTERNAL_SERVER_ERROR);
	    	}
	        @ExceptionHandler(InfyLaptopServiceException.class)
	    	public ResponseEntity<ErrorInfo>InfyLaptopServiceExceptionHandler(InfyLaptopServiceException ex){
	    		logger.error(ex.getMessage(),ex);
	    		ErrorInfo errorInfo=new ErrorInfo();
	    		errorInfo.setErrorCode(HttpStatus.BAD_REQUEST.value());
	    		errorInfo.setErrorMsg(environment.getProperty(ex.getMessage()));
	    		return new ResponseEntity<>(errorInfo,HttpStatus.BAD_REQUEST);
	    	}
	        @ExceptionHandler({MethodArgumentNotValidException.class,ConstraintViolationException.class})
	        public ResponseEntity<ErrorInfo>exceptionHandler(Exception ex){}
	        //ServiceImpl
	        public Integer addNewEmp(EmployeeDTO employeeDto) throws InfyLaptopServiceException{
	        	EmployeeEntity employee=infyEmployeeRepo.findByEmailId(employeeDto.getEmailId());
	        	if(employee!=null) {
	        		throw new InfyLaptopServiceException("INFYLAPTOPSERVICEIMPL.EMAILID_ALREADY_PRESENT");
	        	}
	        	EmployeeEntity emp = new EmployeeEntity();
	        	emp.setContactNo(employeeDto.getContactNo());
	        	emp.setEmailId(employeeDto.getEmailId());
	        	emp.setEmpId(employeeDto.getEmpId());
	        	emp.setEmpName(employeeDto.getEmpName());
	        	emp.setJoiningDate(employeeDto.getJoiningDate());
	        	emp.setLaptopAllocatedTill(employeeDto.getLaptopAllocatedTill());
	        	emp.setMappedToProject(employeeDto.getMappedToProject());
	        	
	        	LaptopEntity l = new LaptopEntity();
	        	LaptopDTO ld = employeeDto.getLaptop();
	        	l.setAllocated(ld.getAllocated());
	        	l.setMachineName(ld.getMachineName());
	        	l.setMake(ld.getMake());
	        	emp.setLaptopEntity(l);
	        	return infyEmployeeRepo.save(emp).getEmpId();
	        }
	        //infyLaptopApi
	        @RestController
	    	@Validated
	    	public class InfyLaptopAPI{
	        	@Autowired
	        	private InfyLaptopService infyLaptopService;
	        	
	        	@PostMapping(value="employee")
	        	public ResponseEntity<EmployeeDTO> addNewEmp(@RequestBody @Valid EmployeeDTO employeeDto)
	        	throws InfyLaptopServiceException{
	        		Integer empId = infyLaptopService.addNewEmp(employeeDto);
	        		employeeDto.setEmpId(empId);
	        		return new ResponseEntity<EmployeeDTO>(employeeDto,HttpStatus.CREATED);
	        	}
	        	@PostMapping(value="laptopAllocation")
	        	public String addLaptopAllocation(@RequestParam @NotNull(message="{employee.id.notpresent}")
	        	@Min(value=1,message="{employee.id.invalid}")Integer empId)throws InfyLaptopServiceException{
	        		String message = infyLaptopService.addLaptopAllocation(empId);
	        		return message;
	        	}
	        	@GetMapping(value="laptopAllocation/{empId}")
	        	public EmployeeDTO getLaptopAllocation(@PathVariable @NotNull(message="{employee.id.notpresent}")
	        	@Min(value=1,message="{employee.id.invalid}")
	        	Integer emId) throws InfyLaptopServiceException{
	        		EmployeeDTO employeeDto=infyLaptopService.getLaptopAllocation(empId);
	        		return employeeDto;
	        	}
	        	@PutMapping(value="laptopAllocation")
	        	public String extendLaptopAllocation(@RequestParam @NotNull(message="{employee.id.notpresent}")
	        	@Min(value=1,message="{employee.id.invalid}")Integer emId) throws InfyLaptopServiceException{
	        		
	        	}
	        }
//=======================================================================================================================
MORTGAGE
//Application properties
	       server.port=2525
			server.servlet.context-path=/mortgage
			//CustomerServiceImpl
			public List<LoanDTO> fetchAllLoansForCustomer(String panNumber) throws MortgageException{
	    	   Optional<Customer> opCustomer=customerRepo.findById(panNumber);
	    	   Customer customer=opCustomer.orElseThrow(()->new MortgageException("Service_CustomerNotFound"));
	    	   List<Loan> loanList=loanRepository.findLoanByCustomerPanNumber(panNumber);
	    	   if(loanList.isEmpty()) {
	    		   throw new MortgageException("Service_No_Loan");
	    	   }
	    	   List<LoanDTO> loanDtoList = new ArrayList<>();
	    	   for(Loan loan:loanList) {
	    		   loanDtoList.add(Loan.prepareDTO(loan));
	    	   }
	       return loanDtoList;
	       }
	       //LoanApplicationServiceImpl
	       public Integer applyLoan(LoanDTO loanDTO) throws MortgageException{
	    	   Optional<Customer> opCustomer=customerRepository.findById(loanDTO.getPanNumber());
	    	   Customer customer=opCustomer.orElseThrow(()->new MortgageException("Service_CustomerNotFound"));
	    	   Optional<Property> opProperty=propertyRepository.findById(loanDTO.getProperty().getPropertyNumber());
	    	   Property property=opProperty.orElseThrow(()->new MortgageException("Service_Property_Used"));
	    	   Loan loan = LoanDTO.prepareEntity(loanDTO);
	    	   loan.setEmi(0.0);
	    	   Loan savedLoan=loanRepository.save(loan);
	    	   return savedLoan.getLoanId();
	       }
	       public Loan loanEvaluation(Integer loanId,Double estimatedValue) throws MortgageException{
	    	   Optional<Loan> opLoan=loanRepository.findById(loanId);
	    	   Loan loan=opLoan.orElseThrow(()->new MortgageException("Service_LOAN_DOES_NOT_EXIST"));
	    	   if(!loan.getStatus().equals(LoanStatus.PENDING)) {
	    		   throw new MortgageException("Service_LOAN_CANNOT_UPDATE");
	    	   }
	    	   if(estimatedValue<loan.getRequiredAmount()) {
	    		   throw new MortgageException("Service_LOAN_CANNOT_INITIATE");
	    	   }else {
	    		   Double principalAmount=loan.getRequiredAmount();
	    		   double monthlyInterestRate = INTEREST_RATE /12/100;
	    		   int totalMonths = loan.getLoanTenure();
	    		   double EMI = Math.round(principalAmount*monthlyInterestRate*Math.pow(1 + monthlyInterestRate, totalMonths));
	    		   List<Loan> loanList=loanRepository.findLoanByCustomerPanNumber(loan.getCustomer().getPanNumber());
	    		   if(loanList.size()>1) {
	    			   Double sum=0.0;
	    			   for(Loan l:loanList) {
	    				   sum+=l.getEmi();
	    			   }
	    			   if(loan.getCustomer().getMonthlyIncome()-sum>EMI) {
	    				   loan.setStatus(LoanStatus.APPROVED);
	    				   loan.setLoanAmount(principalAmount);
	    				   loan.setEmi(EMI);
	    			   }
	    			   else {
	    				   loan.setStatus(LoanStatus.REJECTED);
	    			   }
	    		   }
	    		   else {
	    			   if(loan.getCustomer().getMonthlyIncome()>EMI) {
	    				   loan.setStatus(LoanStatus.APPROVED);
	    				   loan.setLoanAmount(principalAmount);
	    				   loan.setEmi(EMI);
	    			   }
	    			   else {
	    				   loan.setStatus(LoanStatus.REJECTED);
	    			   }
	    		   }
	    		   if(loan.getStatus().equals(LoanStatus.REJECTED)) {
	    			   throw new MortgageException("Service_LOAN_REJECTED");
	    		   }
	    		   else {
	    			   Loan savedLoan=loanRepository.save(loan);
	    			   return savedLoan;
	    		   }
	    	   }   
	       }
	       //ExceptionController
	       @RestControllerAdvice
	 	  public class ExceptionController
private final Logger logger = LoggerFactory.getLogger(this.getClass());
	 	  @Autowired
	 	  private Environment environment;
	 	@ExceptionHandler(Exception.class)
	 	public ResponseEntity<ErrorInfo>generalExceptionHandler(Exception ex){
	 		logger.error(ex.getMessage(),ex);
	 		ErrorInfo errorInfo=new ErrorInfo();
	 		errorInfo.setErrorCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
	 		errorInfo.setErrorMsg(environment.getProperty(ex.getMessage()));
	 		return new ResponseEntity<>(errorInfo,HttpStatus.INTERNAL_SERVER_ERROR);
	 	}
	 	@ExceptionHandler(MortgageException.class)
	 	public ResponseEntity<ErrorInfo>MortgageExceptionHandler(MortgageException ex){
	 		logger.error(ex.getMessage(),ex);
	 		ErrorInfo errorInfo=new ErrorInfo();
	 		errorInfo.setErrorCode(HttpStatus.BAD_REQUEST.value());
	 		errorInfo.setErrorMsg(environment.getProperty(ex.getMessage()));
	 		return new ResponseEntity<>(errorInfo,HttpStatus.BAD_REQUEST);
	 	}
	 	@ExceptionHandler({MethodArgumentNotValidException.class,ConstraintViolationException.class})
	     public ResponseEntity<ErrorInfo>exceptionHandler(Exception ex){}
	       //LoanDTO
	       @NotNull(message="{Customer_pan_null}")
	       @Pattern(regexp="[A-Z]{5}[0-9]{4}[A-Z]{1}",message="{Customer_pan_invalid}")
	       private String panNumber;
	       @NotNull(message="{Loan_property_Null}")
	       private PropertyDTO property;
	       //CustomerDTO
	       @NotNull(message="{Customer_pan_null}")
	       @Pattern(regexp="[A-Z]{5}[0-9]{4}[A-Z]{1}",message="{Customer_pan_invalid}")
	       private String panNumber;
	       @NotNull(message="{Customer_phone_null}")
	       @Pattern(regexp="(6|7|8|9)[0-9]{9}",message="{Customer_Phone_invalid}")
	       private String phone;
	       @Email(message="{Customer_email_invalid}")
	       private String email;
	       @NotNull(message="{Customer_salary_null}")
	       private Double monthlyIncome;
	       @NotNull(message="{Customer_creditScore_null}")
	       @Min(value=300,message="{Customer_Credit_invalid}")
	       @Max(value=900,message="{Customer_Credit_invalid")
	       private Integer creditScore;
	       //ManagementController
	       @RestController
	       @RequestMapping(value="/loan")
	       @Validated
	       public class MortgageManagementController{
	    	   @Autowired
	    	   private CustomerService customerService;
	    	   @Autowired
	    	   private LoanApplicationService loanApplicationService;
	    	   
	    	  @PostMapping(value="/register")
	    	  public ResponseEntity<String> customerRegistration(@Valid @RequestBody CustomerDTO customerDTO) throws MortgageException{
	    		  String panNumber=customerService.customerRegistration(customerDTO);
	    		  return new ResponseEntity<>("Customer has been registered successfully with customer id :"+panNumber,HttpStatus.CREATED);
	    	  }
	    	  @GetMapping(value="/{id}")
	    	  public ResponseEntity<List<LoanDTO>> fetchAllLoansForCustomer(@PathVariable("id") @Valid @RequestBody String panNumber) throws MortgageException{
	    		  List<LoanDTO> loanDtoList=customerService.fetchAllLoansForCustomer(panNumber);
	    		  return new ResponseEntity<>(loanDtoList,HttpStatus.OK);
	    	  }
	    	  @PostMapping(value="/applyloan")
	    	  public ResponseEntity<String> applyLoan (@Valid @RequestBody LoanDTO loanDTO) throws MortgageException{
	    		  Integer loanId=loanApplicationService.applyLoan(loanDTO);
	    		  return new ResponseEntity<>("you have successfully applied for Mortgage with loan Id:" +loanId,HttpStatus.CREATED);
	    	  }
	    	  @PutMapping(value="/{loanId}")
	    	  public ResponseEntity<String> loanApplicationReview(@PathVariable("loanId") Integer loanId) throws MortgageException{
	    		  String message = loanApplicationService.loanApplicationReview(loanId);
	    		  return new ResponseEntity<>(message,HttpStatus.OK);
	    	  }
	    	  @PutMapping(value="/evaluation")
	    	  public ResponseEntity<Loan> loanEvaluation(@RequestParam Integer loanId, @RequestParam Double estimatedValue) throws MortgageException{
	    		  Loan loan=loanApplicationService.loanEvaluation(loanId, estimatedValue);
	    		  return new ResponseEntity<>(loan,HttpStatus.OK);
	    	  }
	    	   
	       }
	       
